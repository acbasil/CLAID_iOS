// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: claidservice.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Claidservice_CtrlType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case ctrlUnspecified // = 0

  /// Client sends this upon connect and periodically if no packages have been sent
  case ctrlRuntimePing // = 1

  /// RemoteClient sends this upon connect to a RemoteDispatcherServer upon connect.
  case ctrlRemotePing // = 2

  /// Response to a CTRL_REMOTE_PING.
  case ctrlRemotePingPong // = 3

  /// Signal by the client that it is about to cancel the request.
  case ctrlConnCancel // = 4

  /// CTRL_MODULE_READY  = 5;  // sent to module when the local middleware is ready
  /// CTRL_STATUS        = 6;  // Sent from a middleware client up the tree
  /// CTRL_ACTION        = 7;  // sent to module when the local middleware is ready
  case ctrlError // = 8

  /// If RemoteDispatcherClient connected to a Server
  case ctrlConnectedToRemoteServer // = 9
  case ctrlDisconnectedFromRemoteServer // = 10
  case ctrlUnloadModules // = 11
  case ctrlUnloadModulesDone // = 12
  case ctrlRestartRuntime // = 13
  case ctrlRestartRuntimeDone // = 14

  /// Stops a runtime.
  case ctrlStopRuntime // = 15
  case ctrlRequestModuleAnnotations // = 16
  case ctrlRequestModuleAnnotationsResponse // = 17

  /// Will be received by the middleware (not forwarded to the Runtimes). Can be used to load a new config into a host alongside with additional data (model files, python code to inject etc.). Requires designer_mode in CLAIDConfig to be true.
  case ctrlUploadConfigAndData // = 18

  /// Will be sent by the middleware to all local Runtimes after the Middleware received a package of type CTRL_UPLOAD_CONFIG_AND_DATA. Informs the Runtimes that new payloads are available.
  case ctrlOnNewConfigPayloadData // = 19

  /// Can be used by the individual runtimes connected to the middleware to forward log messages to the middleware, which might forward it to the log sink host.
  case ctrlLocalLogMessage // = 20

  /// Can be used by CLAID instances to stream log messages to the log sink host. Might be send out by the middleware when a CTRL_LOCAL_LOG_MESSAGE was received by any local runtime.
  case ctrlLogSinkLogMessageStream // = 21

  /// Can be used by local Runtimes to subscribe to the log sink log messages stream. Only works if the current host is the log sink host.
  case ctrlSubscribeToLogSinkLogMessageStream // = 22

  /// Can be used by local Runtimes to unsubscribe from the log sink log messages stream. 
  case ctrlUnsubscribeFromLogSinkLogMessageStream // = 23

  /// Can be used by local Runtimes to pause Modules running on the same host.
  case ctrlPauseModule // = 24

  /// Can be used by local Runtimes to unpause Modules running on the same host.
  case ctrlUnpauseModule // = 25

  /// Can be used by local Runtimes to change the PowerProfile of Modules running on the same host. Only works if a Module supports power profiles.
  case ctrlAdjustPowerProfile // = 26

  /// Can be used to activate network connections after they have been activated by CTRL_DEACTIVATE_NETWORK_CONNECTIONS.
  case ctrlActivateNetworkConnections // = 27

  /// Can be used to deactivate all RemoteDispatcherClient and Servers, i.e., cutting all external connections.
  case ctrlDeactivateNetworkConnections // = 28

  /// Can be used to execute a remote function (RPC call, e.g., a registered function of a Module).
  case ctrlRemoteFunctionRequest // = 29

  /// Response to a remote function request (upon successful or unsuccessful execution of a remote function), if function has return type, this type might be contained in payload of DataPackage
  case ctrlRemoteFunctionResponse // = 30

  /// To forward data via a loose direct subscription.
  case ctrlDirectSubscriptionData // = 31
  case UNRECOGNIZED(Int)

  public init() {
    self = .ctrlUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ctrlUnspecified
    case 1: self = .ctrlRuntimePing
    case 2: self = .ctrlRemotePing
    case 3: self = .ctrlRemotePingPong
    case 4: self = .ctrlConnCancel
    case 8: self = .ctrlError
    case 9: self = .ctrlConnectedToRemoteServer
    case 10: self = .ctrlDisconnectedFromRemoteServer
    case 11: self = .ctrlUnloadModules
    case 12: self = .ctrlUnloadModulesDone
    case 13: self = .ctrlRestartRuntime
    case 14: self = .ctrlRestartRuntimeDone
    case 15: self = .ctrlStopRuntime
    case 16: self = .ctrlRequestModuleAnnotations
    case 17: self = .ctrlRequestModuleAnnotationsResponse
    case 18: self = .ctrlUploadConfigAndData
    case 19: self = .ctrlOnNewConfigPayloadData
    case 20: self = .ctrlLocalLogMessage
    case 21: self = .ctrlLogSinkLogMessageStream
    case 22: self = .ctrlSubscribeToLogSinkLogMessageStream
    case 23: self = .ctrlUnsubscribeFromLogSinkLogMessageStream
    case 24: self = .ctrlPauseModule
    case 25: self = .ctrlUnpauseModule
    case 26: self = .ctrlAdjustPowerProfile
    case 27: self = .ctrlActivateNetworkConnections
    case 28: self = .ctrlDeactivateNetworkConnections
    case 29: self = .ctrlRemoteFunctionRequest
    case 30: self = .ctrlRemoteFunctionResponse
    case 31: self = .ctrlDirectSubscriptionData
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ctrlUnspecified: return 0
    case .ctrlRuntimePing: return 1
    case .ctrlRemotePing: return 2
    case .ctrlRemotePingPong: return 3
    case .ctrlConnCancel: return 4
    case .ctrlError: return 8
    case .ctrlConnectedToRemoteServer: return 9
    case .ctrlDisconnectedFromRemoteServer: return 10
    case .ctrlUnloadModules: return 11
    case .ctrlUnloadModulesDone: return 12
    case .ctrlRestartRuntime: return 13
    case .ctrlRestartRuntimeDone: return 14
    case .ctrlStopRuntime: return 15
    case .ctrlRequestModuleAnnotations: return 16
    case .ctrlRequestModuleAnnotationsResponse: return 17
    case .ctrlUploadConfigAndData: return 18
    case .ctrlOnNewConfigPayloadData: return 19
    case .ctrlLocalLogMessage: return 20
    case .ctrlLogSinkLogMessageStream: return 21
    case .ctrlSubscribeToLogSinkLogMessageStream: return 22
    case .ctrlUnsubscribeFromLogSinkLogMessageStream: return 23
    case .ctrlPauseModule: return 24
    case .ctrlUnpauseModule: return 25
    case .ctrlAdjustPowerProfile: return 26
    case .ctrlActivateNetworkConnections: return 27
    case .ctrlDeactivateNetworkConnections: return 28
    case .ctrlRemoteFunctionRequest: return 29
    case .ctrlRemoteFunctionResponse: return 30
    case .ctrlDirectSubscriptionData: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_CtrlType] = [
    .ctrlUnspecified,
    .ctrlRuntimePing,
    .ctrlRemotePing,
    .ctrlRemotePingPong,
    .ctrlConnCancel,
    .ctrlError,
    .ctrlConnectedToRemoteServer,
    .ctrlDisconnectedFromRemoteServer,
    .ctrlUnloadModules,
    .ctrlUnloadModulesDone,
    .ctrlRestartRuntime,
    .ctrlRestartRuntimeDone,
    .ctrlStopRuntime,
    .ctrlRequestModuleAnnotations,
    .ctrlRequestModuleAnnotationsResponse,
    .ctrlUploadConfigAndData,
    .ctrlOnNewConfigPayloadData,
    .ctrlLocalLogMessage,
    .ctrlLogSinkLogMessageStream,
    .ctrlSubscribeToLogSinkLogMessageStream,
    .ctrlUnsubscribeFromLogSinkLogMessageStream,
    .ctrlPauseModule,
    .ctrlUnpauseModule,
    .ctrlAdjustPowerProfile,
    .ctrlActivateNetworkConnections,
    .ctrlDeactivateNetworkConnections,
    .ctrlRemoteFunctionRequest,
    .ctrlRemoteFunctionResponse,
    .ctrlDirectSubscriptionData,
  ]

}

public enum Claidservice_Codec: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Just a bytes blob (no-op codec)
  case bytes // = 1

  /// File blob
  case file // = 2

  /// JSON data (maybe decode)
  case json // = 3

  /// Decode based on registry
  case proto // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .bytes
    case 2: self = .file
    case 3: self = .json
    case 4: self = .proto
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .bytes: return 1
    case .file: return 2
    case .json: return 3
    case .proto: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_Codec] = [
    .unspecified,
    .bytes,
    .file,
    .json,
    .proto,
  ]

}

public enum Claidservice_PropertyType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// property type not further specified (i.e., input text in the CLAID designer).
  case `default` // = 0
  case `enum` // = 1
  case int // = 2
  case path // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .enum
    case 2: self = .int
    case 3: self = .path
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .enum: return 1
    case .int: return 2
    case .path: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_PropertyType] = [
    .default,
    .enum,
    .int,
    .path,
  ]

}

public enum Claidservice_Runtime: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case middlewareCore // = 1
  case cpp // = 2
  case dart // = 3
  case java // = 4
  case python // = 5
  case swift // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .middlewareCore
    case 2: self = .cpp
    case 3: self = .dart
    case 4: self = .java
    case 5: self = .python
    case 6: self = .swift
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .middlewareCore: return 1
    case .cpp: return 2
    case .dart: return 3
    case .java: return 4
    case .python: return 5
    case .swift: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_Runtime] = [
    .unspecified,
    .middlewareCore,
    .cpp,
    .dart,
    .java,
    .python,
    .swift,
  ]

}

public enum Claidservice_LogMessageSeverityLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case debugVerbose // = 0
  case info // = 1
  case warning // = 2
  case error // = 3
  case fatal // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .debugVerbose
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .debugVerbose
    case 1: self = .info
    case 2: self = .warning
    case 3: self = .error
    case 4: self = .fatal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .debugVerbose: return 0
    case .info: return 1
    case .warning: return 2
    case .error: return 3
    case .fatal: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_LogMessageSeverityLevel] = [
    .debugVerbose,
    .info,
    .warning,
    .error,
    .fatal,
  ]

}

public enum Claidservice_LogMessageEntityType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// For general messages, i.e., sent from low level middleware functions
  case middleware // = 0

  /// For messages from certain well-defined components within the middleware, e.g., the Router oder RemoteDispatcher
  case middlewareComponent // = 1

  /// For log messages directly sent from a certain Module
  case module // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .middleware
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .middleware
    case 1: self = .middlewareComponent
    case 2: self = .module
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .middleware: return 0
    case .middlewareComponent: return 1
    case .module: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_LogMessageEntityType] = [
    .middleware,
    .middlewareComponent,
    .module,
  ]

}

/// Determines how log messages shall be transfered to the log sink host
/// STORE_AND_UPLOAD is the default option. Log messages will be written to files (one file per hour),
/// which will be synchronized with the log sync host once it is available.
/// STREAM is an option that can be used if hosts shall livestream their log messages to the log sink host.
/// This allows to stream the logs in realtime to the log sink host, however log messages will get lost if there currently is no connection to the log sink host
public enum Claidservice_LogSinkTransferMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case storeAndUpload // = 0
  case stream // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .storeAndUpload
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .storeAndUpload
    case 1: self = .stream
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .storeAndUpload: return 0
    case .stream: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_LogSinkTransferMode] = [
    .storeAndUpload,
    .stream,
  ]

}

public enum Claidservice_PowerProfileType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Default profile
  case unrestricted // = 0

  /// Power saving profile
  case powerSavingMode // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unrestricted
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unrestricted
    case 2: self = .powerSavingMode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unrestricted: return 0
    case .powerSavingMode: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_PowerProfileType] = [
    .unrestricted,
    .powerSavingMode,
  ]

}

public enum Claidservice_RemoteFunctionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case statusOk // = 1
  case failedFunctionNotFoundOrFailedToExecute // = 2
  case failedInvalidNumberOfParameters // = 3
  case failedMismatchingParameters // = 4
  case failedModuleNotFound // = 5
  case remoteFunctionRequestInvalid // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .statusOk
    case 2: self = .failedFunctionNotFoundOrFailedToExecute
    case 3: self = .failedInvalidNumberOfParameters
    case 4: self = .failedMismatchingParameters
    case 5: self = .failedModuleNotFound
    case 6: self = .remoteFunctionRequestInvalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .statusOk: return 1
    case .failedFunctionNotFoundOrFailedToExecute: return 2
    case .failedInvalidNumberOfParameters: return 3
    case .failedMismatchingParameters: return 4
    case .failedModuleNotFound: return 5
    case .remoteFunctionRequestInvalid: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_RemoteFunctionStatus] = [
    .undefined,
    .statusOk,
    .failedFunctionNotFoundOrFailedToExecute,
    .failedInvalidNumberOfParameters,
    .failedMismatchingParameters,
    .failedModuleNotFound,
    .remoteFunctionRequestInvalid,
  ]

}

public enum Claidservice_DataSyncPackageType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case allAvailableFilesList // = 0
  case requestedFilesList // = 1
  case filesData // = 2
  case acknowledgedFiles // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .allAvailableFilesList
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .allAvailableFilesList
    case 1: self = .requestedFilesList
    case 2: self = .filesData
    case 3: self = .acknowledgedFiles
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .allAvailableFilesList: return 0
    case .requestedFilesList: return 1
    case .filesData: return 2
    case .acknowledgedFiles: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Claidservice_DataSyncPackageType] = [
    .allAvailableFilesList,
    .requestedFilesList,
    .filesData,
    .acknowledgedFiles,
  ]

}

public struct Claidservice_DataPackage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of this package
  public var id: String = String()

  public var channel: String = String()

  /// originating module id
  public var sourceModule: String = String()

  /// target module id
  public var targetModule: String = String()

  /// originating host name
  public var sourceHost: String = String()

  /// target host name
  public var targetHost: String = String()

  /// id token of the user / system entity that created this package.
  public var sourceUserToken: String = String()

  /// id of the user / system that this package is intended for, if it is intended to send data to a module of a specific user.
  public var targetUserToken: String = String()

  /// typically, this will be *, meaning that the package will be forwarded to all users that run the corresponding host.
  public var deviceID: String = String()

  public var tracePoints: [Claidservice_TracePoint] = []

  /// unix timestamp in milliseconds of when the package was created
  public var unixTimestampMs: UInt64 = 0

  public var payload: Claidservice_Blob {
    get {return _payload ?? Claidservice_Blob()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var controlVal: Claidservice_ControlPackage {
    get {return _controlVal ?? Claidservice_ControlPackage()}
    set {_controlVal = newValue}
  }
  /// Returns true if `controlVal` has been explicitly set.
  public var hasControlVal: Bool {return self._controlVal != nil}
  /// Clears the value of `controlVal`. Subsequent reads from it will return its default value.
  public mutating func clearControlVal() {self._controlVal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payload: Claidservice_Blob? = nil
  fileprivate var _controlVal: Claidservice_ControlPackage? = nil
}

public struct Claidservice_ControlPackage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ctrlType: Claidservice_CtrlType {
    get {return _storage._ctrlType}
    set {_uniqueStorage()._ctrlType = newValue}
  }

  /// CTRL_RUNTIME_PING, CTRL_ADD_MODULE, CTRL_REMOVE_MODULE, CTRL_ADD_MODULE_SUCCESS, CTRL_REMOVE_MODULE_SUCCESS
  public var runtime: Claidservice_Runtime {
    get {return _storage._runtime}
    set {_uniqueStorage()._runtime = newValue}
  }

  /// CTRL_REMOTE_PING
  public var remoteClientInfo: Claidservice_RemoteClientInfo {
    get {return _storage._remoteClientInfo ?? Claidservice_RemoteClientInfo()}
    set {_uniqueStorage()._remoteClientInfo = newValue}
  }
  /// Returns true if `remoteClientInfo` has been explicitly set.
  public var hasRemoteClientInfo: Bool {return _storage._remoteClientInfo != nil}
  /// Clears the value of `remoteClientInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteClientInfo() {_uniqueStorage()._remoteClientInfo = nil}

  /// CTRL_STATUS: status sent towards root server
  public var status: Claidservice_AccumulatedStatus {
    get {return _storage._status ?? Claidservice_AccumulatedStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// CTRL_ERROR: Error report sent towards root server
  public var errorMsg: Claidservice_ErrorMsg {
    get {return _storage._errorMsg ?? Claidservice_ErrorMsg()}
    set {_uniqueStorage()._errorMsg = newValue}
  }
  /// Returns true if `errorMsg` has been explicitly set.
  public var hasErrorMsg: Bool {return _storage._errorMsg != nil}
  /// Clears the value of `errorMsg`. Subsequent reads from it will return its default value.
  public mutating func clearErrorMsg() {_uniqueStorage()._errorMsg = nil}

  /// CTRL_ACTION: action request sent to all children of the claid instance
  public var actionRequest: Claidservice_ActionRequest {
    get {return _storage._actionRequest ?? Claidservice_ActionRequest()}
    set {_uniqueStorage()._actionRequest = newValue}
  }
  /// Returns true if `actionRequest` has been explicitly set.
  public var hasActionRequest: Bool {return _storage._actionRequest != nil}
  /// Clears the value of `actionRequest`. Subsequent reads from it will return its default value.
  public mutating func clearActionRequest() {_uniqueStorage()._actionRequest = nil}

  /// CTRL_REQUEST_MODULE_ANNOTATIONS_RESPONSE
  public var moduleAnnotations: Dictionary<String,Claidservice_ModuleAnnotation> {
    get {return _storage._moduleAnnotations}
    set {_uniqueStorage()._moduleAnnotations = newValue}
  }

  /// CTRL_UPLOAD_CONFIG_AND_DATA and CTRL_ON_NEW_CONFIG_PAYLOAD_DATA
  public var configUploadPayload: Claidservice_ConfigUploadPayload {
    get {return _storage._configUploadPayload ?? Claidservice_ConfigUploadPayload()}
    set {_uniqueStorage()._configUploadPayload = newValue}
  }
  /// Returns true if `configUploadPayload` has been explicitly set.
  public var hasConfigUploadPayload: Bool {return _storage._configUploadPayload != nil}
  /// Clears the value of `configUploadPayload`. Subsequent reads from it will return its default value.
  public mutating func clearConfigUploadPayload() {_uniqueStorage()._configUploadPayload = nil}

  /// CTRL_LOCAL_LOG_MESSAGE and CTRL_LOG_MESSAGE_STREAM_TO_LOG_SINK
  public var logMessage: Claidservice_LogMessage {
    get {return _storage._logMessage ?? Claidservice_LogMessage()}
    set {_uniqueStorage()._logMessage = newValue}
  }
  /// Returns true if `logMessage` has been explicitly set.
  public var hasLogMessage: Bool {return _storage._logMessage != nil}
  /// Clears the value of `logMessage`. Subsequent reads from it will return its default value.
  public mutating func clearLogMessage() {_uniqueStorage()._logMessage = nil}

  /// CTRL_ADJUST_POWER_PROFILE, can be used to tell Modules to enter power saving mode.
  public var powerProfile: Claidservice_PowerProfile {
    get {return _storage._powerProfile ?? Claidservice_PowerProfile()}
    set {_uniqueStorage()._powerProfile = newValue}
  }
  /// Returns true if `powerProfile` has been explicitly set.
  public var hasPowerProfile: Bool {return _storage._powerProfile != nil}
  /// Clears the value of `powerProfile`. Subsequent reads from it will return its default value.
  public mutating func clearPowerProfile() {_uniqueStorage()._powerProfile = nil}

  /// CTRL_REMOTE_FUNCTION_REQUEST
  public var remoteFunctionRequest: Claidservice_RemoteFunctionRequest {
    get {return _storage._remoteFunctionRequest ?? Claidservice_RemoteFunctionRequest()}
    set {_uniqueStorage()._remoteFunctionRequest = newValue}
  }
  /// Returns true if `remoteFunctionRequest` has been explicitly set.
  public var hasRemoteFunctionRequest: Bool {return _storage._remoteFunctionRequest != nil}
  /// Clears the value of `remoteFunctionRequest`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteFunctionRequest() {_uniqueStorage()._remoteFunctionRequest = nil}

  /// CTRL_REMOTE_FUNCTION_RESPONSE
  public var remoteFunctionReturn: Claidservice_RemoteFunctionReturn {
    get {return _storage._remoteFunctionReturn ?? Claidservice_RemoteFunctionReturn()}
    set {_uniqueStorage()._remoteFunctionReturn = newValue}
  }
  /// Returns true if `remoteFunctionReturn` has been explicitly set.
  public var hasRemoteFunctionReturn: Bool {return _storage._remoteFunctionReturn != nil}
  /// Clears the value of `remoteFunctionReturn`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteFunctionReturn() {_uniqueStorage()._remoteFunctionReturn = nil}

  /// CTRL_DIRECT_SUBSCRIPTION_DATA
  public var looseDirectSubscription: Claidservice_LooseDirectChannelSubscription {
    get {return _storage._looseDirectSubscription ?? Claidservice_LooseDirectChannelSubscription()}
    set {_uniqueStorage()._looseDirectSubscription = newValue}
  }
  /// Returns true if `looseDirectSubscription` has been explicitly set.
  public var hasLooseDirectSubscription: Bool {return _storage._looseDirectSubscription != nil}
  /// Clears the value of `looseDirectSubscription`. Subsequent reads from it will return its default value.
  public mutating func clearLooseDirectSubscription() {_uniqueStorage()._looseDirectSubscription = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TBD
public struct Claidservice_AccumulatedStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ErrorMsg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String = String()

  public var cancel: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TBD
  public var actionParams: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_IntVal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var val: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_DoubleVal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var val: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_NumberArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var val: [Double] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_BoolVal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var val: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_StringVal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var val: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_StringArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var val: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_NumberMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var val: Dictionary<String,Double> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_StringMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var val: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_Blob: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var codec: Claidservice_Codec = .unspecified

  /// The byte blob containing the payload data.
  public var payload: Data = Data()

  /// type and subtype contains meta information to decode the bytes contained above.
  /// See this list of common mime types
  /// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  public var messageType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_TracePoint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeStamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timeStamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timeStamp = newValue}
  }
  /// Returns true if `timeStamp` has been explicitly set.
  public var hasTimeStamp: Bool {return self._timeStamp != nil}
  /// Clears the value of `timeStamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimeStamp() {self._timeStamp = nil}

  /// full module id:  host_id:module_type
  public var nodeID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeStamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Sent by the client (Runtime) to tell the Middleware which Modules it supports.
/// The Middleware will answer with a ModuleListResponse, which contains the Modules
/// that the Middleware wants the runtime client to load.
public struct Claidservice_ModuleListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var runtime: Claidservice_Runtime = .unspecified

  public var supportedModuleClasses: [String] = []

  public var moduleAnnotations: Dictionary<String,Claidservice_ModuleAnnotation> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// List of modules that the runtime client is expected to instantiate.
public struct Claidservice_ModuleListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var descriptors: [Claidservice_ModuleListResponse.ModuleDescriptor] = []

  public var logSeverityLevelForHost: Claidservice_LogMessageSeverityLevel = .debugVerbose

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ModuleDescriptor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var moduleID: String = String()

    public var moduleClass: String = String()

    /// repeated DataPackage channels = 4;
    public var properties: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _properties ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_properties = newValue}
    }
    /// Returns true if `properties` has been explicitly set.
    public var hasProperties: Bool {return self._properties != nil}
    /// Clears the value of `properties`. Subsequent reads from it will return its default value.
    public mutating func clearProperties() {self._properties = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _properties: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  public init() {}
}

/// Sent by the client after the modules have been instantiated
/// to inform the server what channels will be sent.
public struct Claidservice_InitRuntimeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var runtime: Claidservice_Runtime = .unspecified

  public var modules: [Claidservice_InitRuntimeRequest.ModuleChannels] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ModuleChannels: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var moduleID: String = String()

    /// channel, source | target, payload => define the channel
    public var channelPackets: [Claidservice_DataPackage] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Claidservice_RemoteClientInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var userToken: String = String()

  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used by CTRL_REMOVE_MODULE to remove a Module at Runtime.
public struct Claidservice_RemoveModuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var moduleID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_PropertyHint: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var propertyType: Claidservice_PropertyType = .default

  /// If the property type is ENUM, then property_type_enum_values contains the possible names of enum values.
  public var propertyTypeEnumValues: [String] = []

  /// If the property type is INT, then property_type_int_min indicates the minimum supported value for that property.
  public var propertyTypeIntMin: Int64 = 0

  /// If the property type is INT, then property_type_int_max indicates the maximum supported value for that property.
  public var propertyTypeIntMax: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ModuleAnnotation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var moduleDescription: String = String()

  public var moduleCategory: String = String()

  public var properties: [String] = []

  public var propertyDescriptions: [String] = []

  public var propertyHints: [Claidservice_PropertyHint] = []

  public var channelDefinition: [Claidservice_DataPackage] = []

  public var channelDescription: [String] = []

  public var isInjectable: Bool = false

  public var fileDependencies: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_LogMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var logMessage: String = String()

  public var severityLevel: Claidservice_LogMessageSeverityLevel = .debugVerbose

  public var unixTimestampInMs: UInt64 = 0

  public var entityType: Claidservice_LogMessageEntityType = .middleware

  public var entityName: String = String()

  /// Runtime from which the message was sent
  public var runtime: Claidservice_Runtime = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Container for the central CLAID config file. 
public struct Claidservice_CLAIDConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hosts: [Claidservice_HostConfig] = []

  /// If specified, all CLAID instances will forward their log messages to this host. 
  public var logSinkHost: String = String()

  /// If log_sink_host is specified, this flag indicates 
  public var logSinkSeverityLevel: Claidservice_LogMessageSeverityLevel = .debugVerbose

  /// what category of log messages will be sent to the log sink (only messages with severity level >= this flag will be sent).
  public var logSinkTransferMode: Claidservice_LogSinkTransferMode = .storeAndUpload

  /// If tranfer mode is store and upload, then this path indicates where to store the temporary files.
  public var logSinkLogStoragePath: String = String()

  ///bool designer_mode = 5;                         // If true, other hosts can upload a new config (alongside additional data like model files or python code) to the host.
  public var millisecondsDeadlineToLoadModules: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_HostConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hostname: String = String()

  public var type: String = String()

  public var serverConfig: Claidservice_ServerConfig {
    get {return _serverConfig ?? Claidservice_ServerConfig()}
    set {_serverConfig = newValue}
  }
  /// Returns true if `serverConfig` has been explicitly set.
  public var hasServerConfig: Bool {return self._serverConfig != nil}
  /// Clears the value of `serverConfig`. Subsequent reads from it will return its default value.
  public mutating func clearServerConfig() {self._serverConfig = nil}

  /// If specified, the host will connect to this address. 
  public var connectTo: Claidservice_ClientConfig {
    get {return _connectTo ?? Claidservice_ClientConfig()}
    set {_connectTo = newValue}
  }
  /// Returns true if `connectTo` has been explicitly set.
  public var hasConnectTo: Bool {return self._connectTo != nil}
  /// Clears the value of `connectTo`. Subsequent reads from it will return its default value.
  public mutating func clearConnectTo() {self._connectTo = nil}

  /// The host can either be a Client connection to a Server, or a Server connecting to another Server.
  public var modules: [Claidservice_ModuleConfig] = []

  /// Path to folder where to store log message to. All log messages with a severity level >= min_log_severity_level will be store there.
  public var logFolder: String = String()

  /// Additionally, all log messages with a severity level >= log_sink_severity_level will be stored separately and synced with the log sink host.
  /// The separately stored messages for the log_sink_host will be deleted upon successfull synchronization;
  public var minLogSeverityLevel: Claidservice_LogMessageSeverityLevel = .debugVerbose

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serverConfig: Claidservice_ServerConfig? = nil
  fileprivate var _connectTo: Claidservice_ClientConfig? = nil
}

public struct Claidservice_ClientConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var securitySettings: Claidservice_ClientConfig.OneOf_SecuritySettings? = nil

  public var tls: Claidservice_ClientTLSConfigServerBasedAuthentication {
    get {
      if case .tls(let v)? = securitySettings {return v}
      return Claidservice_ClientTLSConfigServerBasedAuthentication()
    }
    set {securitySettings = .tls(newValue)}
  }

  public var mutualTls: Claidservice_ClientTLSConfigMutualAuthentication {
    get {
      if case .mutualTls(let v)? = securitySettings {return v}
      return Claidservice_ClientTLSConfigMutualAuthentication()
    }
    set {securitySettings = .mutualTls(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SecuritySettings: Equatable, Sendable {
    case tls(Claidservice_ClientTLSConfigServerBasedAuthentication)
    case mutualTls(Claidservice_ClientTLSConfigMutualAuthentication)

  }

  public init() {}
}

public struct Claidservice_ServerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hostServerAddress: String = String()

  public var securitySettings: Claidservice_ServerConfig.OneOf_SecuritySettings? = nil

  public var tls: Claidservice_ServerTLSConfigServerBasedAuthentication {
    get {
      if case .tls(let v)? = securitySettings {return v}
      return Claidservice_ServerTLSConfigServerBasedAuthentication()
    }
    set {securitySettings = .tls(newValue)}
  }

  public var mutualTls: Claidservice_ServerTLSConfigMutualAuthentication {
    get {
      if case .mutualTls(let v)? = securitySettings {return v}
      return Claidservice_ServerTLSConfigMutualAuthentication()
    }
    set {securitySettings = .mutualTls(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SecuritySettings: Equatable, Sendable {
    case tls(Claidservice_ServerTLSConfigServerBasedAuthentication)
    case mutualTls(Claidservice_ServerTLSConfigMutualAuthentication)

  }

  public init() {}
}

/// TLS features two types of authentication:
/// - Server-based authentication: The client authenticates the server using its public certificate.
///   After the server has been successfully authenticated, client and server exchange a shared secret key, 
///   which will be used to encrypt the data sent between client and server.
/// - Mutual authentication: Both client and server authenticate each other using certificates.
public struct Claidservice_ClientTLSConfigServerBasedAuthentication: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serverPublicCertificate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ClientTLSConfigMutualAuthentication: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clientPublicCertificate: String = String()

  public var clientPrivateKey: String = String()

  public var serverPublicCertificate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ServerTLSConfigServerBasedAuthentication: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serverPublicCertificate: String = String()

  public var serverPrivateKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ServerTLSConfigMutualAuthentication: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var serverPublicCertificate: String = String()

  public var serverPrivateKey: String = String()

  public var clientPublicCertificate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ModuleConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: String = String()

  /// Maps input channels to connections, e.g. "InputAudioDataChannel" : "AudioDataConnection"
  public var inputChannels: Dictionary<String,String> = [:]

  /// Maps output channels to connections, e.g. "AudioDataToProcess" : "AudioDataConnection"
  public var outputChannels: Dictionary<String,String> = [:]

  public var properties: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _properties ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_properties = newValue}
  }
  /// Returns true if `properties` has been explicitly set.
  public var hasProperties: Bool {return self._properties != nil}
  /// Clears the value of `properties`. Subsequent reads from it will return its default value.
  public mutating func clearProperties() {self._properties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _properties: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

public struct Claidservice_DataFile: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var relativePath: String = String()

  public var fileData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ModuleInjectionDescription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Names of modules to inject.
  public var moduleName: String = String()

  /// Name of the file in which the Module can be found. 
  public var moduleFile: String = String()

  /// Runtime which shall inject this module.
  public var runtime: Claidservice_Runtime = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ConfigUploadPayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var config: Claidservice_CLAIDConfig {
    get {return _config ?? Claidservice_CLAIDConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var payloadFiles: [Claidservice_DataFile] = []

  /// Contains names of Modules which were sent as payload and can be injected by the corresponding Runtimes.
  public var modulesToInject: [Claidservice_ModuleInjectionDescription] = []

  /// Current payloadDataPath (path where the middleware stores payloads).
  public var payloadDataPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Claidservice_CLAIDConfig? = nil
}

/// Can be used by Modules to support different Power Profiles. For example, the AccelerometerCollector might support sampling at lower frequencies to reduce battery consumption
public struct Claidservice_PowerProfile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var powerProfileType: Claidservice_PowerProfileType = .unrestricted

  /// FREQUENCY AND PERIOD ARE EXCLUSIVE, USE EITHER ONE OR THE OTHER! IT WILL NOT BE VALIDATED WHETHERE period == 1/frequency !!
  public var frequency: Double = 0

  /// For Modules that collect data in a certain intervall. 
  public var period: Double = 0

  public var additionalInformation: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_PowerSavingStrategy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batteryThreshold: Float = 0

  public var activeModules: [String] = []

  public var pausedModules: [String] = []

  public var powerProfiles: Dictionary<String,Claidservice_PowerProfile> = [:]

  public var wakeLock: Bool = false

  public var disableNetworkConnections: Bool = false

  /// Only on Android or WearOS with advanced device management active.
  public var disableWifiAndBluetooth: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_PowerSavingStrategyList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var strategies: [Claidservice_PowerSavingStrategy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Used by claid::AnyProtoType 
public struct Claidservice_CLAIDANY: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_RemoteFunctionIdentifier: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var functionName: String = String()

  /// Is it a function of a Runtime (e.g., of the C++ or Java runtime)?
  /// Or is it a function of a Module?
  public var functionType: Claidservice_RemoteFunctionIdentifier.OneOf_FunctionType? = nil

  public var runtime: Claidservice_Runtime {
    get {
      if case .runtime(let v)? = functionType {return v}
      return .unspecified
    }
    set {functionType = .runtime(newValue)}
  }

  public var moduleID: String {
    get {
      if case .moduleID(let v)? = functionType {return v}
      return String()
    }
    set {functionType = .moduleID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Is it a function of a Runtime (e.g., of the C++ or Java runtime)?
  /// Or is it a function of a Module?
  public enum OneOf_FunctionType: Equatable, Sendable {
    case runtime(Claidservice_Runtime)
    case moduleID(String)

  }

  public init() {}
}

public struct Claidservice_RemoteFunctionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var remoteFunctionIdentifier: Claidservice_RemoteFunctionIdentifier {
    get {return _remoteFunctionIdentifier ?? Claidservice_RemoteFunctionIdentifier()}
    set {_remoteFunctionIdentifier = newValue}
  }
  /// Returns true if `remoteFunctionIdentifier` has been explicitly set.
  public var hasRemoteFunctionIdentifier: Bool {return self._remoteFunctionIdentifier != nil}
  /// Clears the value of `remoteFunctionIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteFunctionIdentifier() {self._remoteFunctionIdentifier = nil}

  /// Unique identifier for the future which is waiting for the response of the function.
  public var remoteFutureIdentifier: String = String()

  public var parameterPayloads: [Claidservice_Blob] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _remoteFunctionIdentifier: Claidservice_RemoteFunctionIdentifier? = nil
}

public struct Claidservice_RemoteFunctionReturn: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var executionStatus: Claidservice_RemoteFunctionStatus = .undefined

  public var remoteFunctionIdentifier: Claidservice_RemoteFunctionIdentifier {
    get {return _remoteFunctionIdentifier ?? Claidservice_RemoteFunctionIdentifier()}
    set {_remoteFunctionIdentifier = newValue}
  }
  /// Returns true if `remoteFunctionIdentifier` has been explicitly set.
  public var hasRemoteFunctionIdentifier: Bool {return self._remoteFunctionIdentifier != nil}
  /// Clears the value of `remoteFunctionIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearRemoteFunctionIdentifier() {self._remoteFunctionIdentifier = nil}

  /// Unique identifier for the future which is waiting for the response of the function.
  public var remoteFutureIdentifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _remoteFunctionIdentifier: Claidservice_RemoteFunctionIdentifier? = nil
}

/// Can be used for non-Module entities to subscribe directly to the data posted to a channel by a certain Module.
/// In regular subscriptions, data is forwarded to all subscribers to a channel, no matter what Module posted the data.
/// In loose direct subscriptions, data is forwarded directly to separate non-module subscribers to a channel, but only if the data 
/// was posted by the Module that the non-module subscriber explicitly subscribed to.
/// This typically is used for UI visualizations, allowing UI widgets to subscribe to data posted by a certain Module.
/// For example, check out CLAIDModuleView of FlutterCLAID.
public struct Claidservice_LooseDirectChannelSubscription: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriberRuntime: Claidservice_Runtime = .unspecified

  public var subscriberEntity: String = String()

  public var subscribedModule: String = String()

  public var subscribedChannel: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_DataSyncFileDescriptor: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fileSize: UInt64 = 0

  public var hash: UInt64 = 0

  public var relativeFilePath: String = String()

  public var fileData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_DataSyncFileDescriptorList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var descriptors: [Claidservice_DataSyncFileDescriptor] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_DataSyncPackage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packageType: Claidservice_DataSyncPackageType = .allAvailableFilesList

  public var fileDescriptors: Claidservice_DataSyncFileDescriptorList {
    get {return _fileDescriptors ?? Claidservice_DataSyncFileDescriptorList()}
    set {_fileDescriptors = newValue}
  }
  /// Returns true if `fileDescriptors` has been explicitly set.
  public var hasFileDescriptors: Bool {return self._fileDescriptors != nil}
  /// Clears the value of `fileDescriptors`. Subsequent reads from it will return its default value.
  public mutating func clearFileDescriptors() {self._fileDescriptors = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fileDescriptors: Claidservice_DataSyncFileDescriptorList? = nil
}

/// Allows to send a runtime via a protobuf message.
public struct Claidservice_RuntimeType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var runtime: Claidservice_Runtime = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Schedule defines specific times for executing functions. 
/// It can be used to automatically register and trigger functions based on defined intervals, time frames, 
/// or specific times of day at each runtime.
public struct Claidservice_Schedule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var periodic: [Claidservice_SchedulePeriodic] = []

  public var timed: [Claidservice_ScheduleExactTime] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_ScheduleTimeWindow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startTimeOfDay: Claidservice_ScheduleTimeOfDay {
    get {return _startTimeOfDay ?? Claidservice_ScheduleTimeOfDay()}
    set {_startTimeOfDay = newValue}
  }
  /// Returns true if `startTimeOfDay` has been explicitly set.
  public var hasStartTimeOfDay: Bool {return self._startTimeOfDay != nil}
  /// Clears the value of `startTimeOfDay`. Subsequent reads from it will return its default value.
  public mutating func clearStartTimeOfDay() {self._startTimeOfDay = nil}

  public var stopTimeOfDay: Claidservice_ScheduleTimeOfDay {
    get {return _stopTimeOfDay ?? Claidservice_ScheduleTimeOfDay()}
    set {_stopTimeOfDay = newValue}
  }
  /// Returns true if `stopTimeOfDay` has been explicitly set.
  public var hasStopTimeOfDay: Bool {return self._stopTimeOfDay != nil}
  /// Clears the value of `stopTimeOfDay`. Subsequent reads from it will return its default value.
  public mutating func clearStopTimeOfDay() {self._stopTimeOfDay = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTimeOfDay: Claidservice_ScheduleTimeOfDay? = nil
  fileprivate var _stopTimeOfDay: Claidservice_ScheduleTimeOfDay? = nil
}

public struct Claidservice_ScheduleTimeOfDay: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hour: Int32 = 0

  public var minute: Int32 = 0

  public var second: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Claidservice_SchedulePeriodic: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. If not specified, periodic function will be started immediately.
  public var firstExecutionTimeOfDay: Claidservice_ScheduleTimeOfDay {
    get {return _firstExecutionTimeOfDay ?? Claidservice_ScheduleTimeOfDay()}
    set {_firstExecutionTimeOfDay = newValue}
  }
  /// Returns true if `firstExecutionTimeOfDay` has been explicitly set.
  public var hasFirstExecutionTimeOfDay: Bool {return self._firstExecutionTimeOfDay != nil}
  /// Clears the value of `firstExecutionTimeOfDay`. Subsequent reads from it will return its default value.
  public mutating func clearFirstExecutionTimeOfDay() {self._firstExecutionTimeOfDay = nil}

  /// Optional. If not specified, periodic function is always active.
  public var onlyActiveBetweenTimeFrame: Claidservice_ScheduleTimeWindow {
    get {return _onlyActiveBetweenTimeFrame ?? Claidservice_ScheduleTimeWindow()}
    set {_onlyActiveBetweenTimeFrame = newValue}
  }
  /// Returns true if `onlyActiveBetweenTimeFrame` has been explicitly set.
  public var hasOnlyActiveBetweenTimeFrame: Bool {return self._onlyActiveBetweenTimeFrame != nil}
  /// Clears the value of `onlyActiveBetweenTimeFrame`. Subsequent reads from it will return its default value.
  public mutating func clearOnlyActiveBetweenTimeFrame() {self._onlyActiveBetweenTimeFrame = nil}

  public var interval: Claidservice_SchedulePeriodic.OneOf_Interval? = nil

  public var frequencyHz: Double {
    get {
      if case .frequencyHz(let v)? = interval {return v}
      return 0
    }
    set {interval = .frequencyHz(newValue)}
  }

  public var frequencyKHz: Double {
    get {
      if case .frequencyKHz(let v)? = interval {return v}
      return 0
    }
    set {interval = .frequencyKHz(newValue)}
  }

  public var frequencyMhz: Double {
    get {
      if case .frequencyMhz(let v)? = interval {return v}
      return 0
    }
    set {interval = .frequencyMhz(newValue)}
  }

  public var periodMilliseconds: Double {
    get {
      if case .periodMilliseconds(let v)? = interval {return v}
      return 0
    }
    set {interval = .periodMilliseconds(newValue)}
  }

  public var periodSeconds: Double {
    get {
      if case .periodSeconds(let v)? = interval {return v}
      return 0
    }
    set {interval = .periodSeconds(newValue)}
  }

  public var periodMinutes: Double {
    get {
      if case .periodMinutes(let v)? = interval {return v}
      return 0
    }
    set {interval = .periodMinutes(newValue)}
  }

  public var periodHours: Double {
    get {
      if case .periodHours(let v)? = interval {return v}
      return 0
    }
    set {interval = .periodHours(newValue)}
  }

  public var periodDays: Double {
    get {
      if case .periodDays(let v)? = interval {return v}
      return 0
    }
    set {interval = .periodDays(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Interval: Equatable, Sendable {
    case frequencyHz(Double)
    case frequencyKHz(Double)
    case frequencyMhz(Double)
    case periodMilliseconds(Double)
    case periodSeconds(Double)
    case periodMinutes(Double)
    case periodHours(Double)
    case periodDays(Double)

  }

  public init() {}

  fileprivate var _firstExecutionTimeOfDay: Claidservice_ScheduleTimeOfDay? = nil
  fileprivate var _onlyActiveBetweenTimeFrame: Claidservice_ScheduleTimeWindow? = nil
}

public struct Claidservice_ScheduleExactTime: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timeOfDay: Claidservice_ScheduleTimeOfDay {
    get {return _timeOfDay ?? Claidservice_ScheduleTimeOfDay()}
    set {_timeOfDay = newValue}
  }
  /// Returns true if `timeOfDay` has been explicitly set.
  public var hasTimeOfDay: Bool {return self._timeOfDay != nil}
  /// Clears the value of `timeOfDay`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOfDay() {self._timeOfDay = nil}

  public var repeatEveryNDays: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeOfDay: Claidservice_ScheduleTimeOfDay? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "claidservice"

extension Claidservice_CtrlType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CTRL_UNSPECIFIED"),
    1: .same(proto: "CTRL_RUNTIME_PING"),
    2: .same(proto: "CTRL_REMOTE_PING"),
    3: .same(proto: "CTRL_REMOTE_PING_PONG"),
    4: .same(proto: "CTRL_CONN_CANCEL"),
    8: .same(proto: "CTRL_ERROR"),
    9: .same(proto: "CTRL_CONNECTED_TO_REMOTE_SERVER"),
    10: .same(proto: "CTRL_DISCONNECTED_FROM_REMOTE_SERVER"),
    11: .same(proto: "CTRL_UNLOAD_MODULES"),
    12: .same(proto: "CTRL_UNLOAD_MODULES_DONE"),
    13: .same(proto: "CTRL_RESTART_RUNTIME"),
    14: .same(proto: "CTRL_RESTART_RUNTIME_DONE"),
    15: .same(proto: "CTRL_STOP_RUNTIME"),
    16: .same(proto: "CTRL_REQUEST_MODULE_ANNOTATIONS"),
    17: .same(proto: "CTRL_REQUEST_MODULE_ANNOTATIONS_RESPONSE"),
    18: .same(proto: "CTRL_UPLOAD_CONFIG_AND_DATA"),
    19: .same(proto: "CTRL_ON_NEW_CONFIG_PAYLOAD_DATA"),
    20: .same(proto: "CTRL_LOCAL_LOG_MESSAGE"),
    21: .same(proto: "CTRL_LOG_SINK_LOG_MESSAGE_STREAM"),
    22: .same(proto: "CTRL_SUBSCRIBE_TO_LOG_SINK_LOG_MESSAGE_STREAM"),
    23: .same(proto: "CTRL_UNSUBSCRIBE_FROM_LOG_SINK_LOG_MESSAGE_STREAM"),
    24: .same(proto: "CTRL_PAUSE_MODULE"),
    25: .same(proto: "CTRL_UNPAUSE_MODULE"),
    26: .same(proto: "CTRL_ADJUST_POWER_PROFILE"),
    27: .same(proto: "CTRL_ACTIVATE_NETWORK_CONNECTIONS"),
    28: .same(proto: "CTRL_DEACTIVATE_NETWORK_CONNECTIONS"),
    29: .same(proto: "CTRL_REMOTE_FUNCTION_REQUEST"),
    30: .same(proto: "CTRL_REMOTE_FUNCTION_RESPONSE"),
    31: .same(proto: "CTRL_DIRECT_SUBSCRIPTION_DATA"),
  ]
}

extension Claidservice_Codec: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODEC_UNSPECIFIED"),
    1: .same(proto: "CODEC_BYTES"),
    2: .same(proto: "CODEC_FILE"),
    3: .same(proto: "CODEC_JSON"),
    4: .same(proto: "CODEC_PROTO"),
  ]
}

extension Claidservice_PropertyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPERTY_TYPE_DEFAULT"),
    1: .same(proto: "PROPERTY_TYPE_ENUM"),
    2: .same(proto: "PROPERTY_TYPE_INT"),
    3: .same(proto: "PROPERTY_TYPE_PATH"),
  ]
}

extension Claidservice_Runtime: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUNTIME_UNSPECIFIED"),
    1: .same(proto: "MIDDLEWARE_CORE"),
    2: .same(proto: "RUNTIME_CPP"),
    3: .same(proto: "RUNTIME_DART"),
    4: .same(proto: "RUNTIME_JAVA"),
    5: .same(proto: "RUNTIME_PYTHON"),
    6: .same(proto: "RUNTIME_SWIFT"),
  ]
}

extension Claidservice_LogMessageSeverityLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEBUG_VERBOSE"),
    1: .same(proto: "INFO"),
    2: .same(proto: "WARNING"),
    3: .same(proto: "ERROR"),
    4: .same(proto: "FATAL"),
  ]
}

extension Claidservice_LogMessageEntityType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MIDDLEWARE"),
    1: .same(proto: "MIDDLEWARE_COMPONENT"),
    2: .same(proto: "MODULE"),
  ]
}

extension Claidservice_LogSinkTransferMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORE_AND_UPLOAD"),
    1: .same(proto: "STREAM"),
  ]
}

extension Claidservice_PowerProfileType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNRESTRICTED"),
    2: .same(proto: "POWER_SAVING_MODE"),
  ]
}

extension Claidservice_RemoteFunctionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "STATUS_OK"),
    2: .same(proto: "FAILED_FUNCTION_NOT_FOUND_OR_FAILED_TO_EXECUTE"),
    3: .same(proto: "FAILED_INVALID_NUMBER_OF_PARAMETERS"),
    4: .same(proto: "FAILED_MISMATCHING_PARAMETERS"),
    5: .same(proto: "FAILED_MODULE_NOT_FOUND"),
    6: .same(proto: "REMOTE_FUNCTION_REQUEST_INVALID"),
  ]
}

extension Claidservice_DataSyncPackageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL_AVAILABLE_FILES_LIST"),
    1: .same(proto: "REQUESTED_FILES_LIST"),
    2: .same(proto: "FILES_DATA"),
    3: .same(proto: "ACKNOWLEDGED_FILES"),
  ]
}

extension Claidservice_DataPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "channel"),
    3: .standard(proto: "source_module"),
    4: .standard(proto: "target_module"),
    5: .standard(proto: "source_host"),
    6: .standard(proto: "target_host"),
    7: .standard(proto: "source_user_token"),
    8: .standard(proto: "target_user_token"),
    9: .standard(proto: "device_id"),
    10: .standard(proto: "trace_points"),
    11: .standard(proto: "unix_timestamp_ms"),
    12: .same(proto: "payload"),
    13: .standard(proto: "control_val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceModule) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetModule) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sourceHost) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.targetHost) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.sourceUserToken) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.targetUserToken) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.tracePoints) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.unixTimestampMs) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._controlVal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 2)
    }
    if !self.sourceModule.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceModule, fieldNumber: 3)
    }
    if !self.targetModule.isEmpty {
      try visitor.visitSingularStringField(value: self.targetModule, fieldNumber: 4)
    }
    if !self.sourceHost.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceHost, fieldNumber: 5)
    }
    if !self.targetHost.isEmpty {
      try visitor.visitSingularStringField(value: self.targetHost, fieldNumber: 6)
    }
    if !self.sourceUserToken.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceUserToken, fieldNumber: 7)
    }
    if !self.targetUserToken.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUserToken, fieldNumber: 8)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 9)
    }
    if !self.tracePoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracePoints, fieldNumber: 10)
    }
    if self.unixTimestampMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.unixTimestampMs, fieldNumber: 11)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._controlVal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_DataPackage, rhs: Claidservice_DataPackage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.sourceModule != rhs.sourceModule {return false}
    if lhs.targetModule != rhs.targetModule {return false}
    if lhs.sourceHost != rhs.sourceHost {return false}
    if lhs.targetHost != rhs.targetHost {return false}
    if lhs.sourceUserToken != rhs.sourceUserToken {return false}
    if lhs.targetUserToken != rhs.targetUserToken {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.tracePoints != rhs.tracePoints {return false}
    if lhs.unixTimestampMs != rhs.unixTimestampMs {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs._controlVal != rhs._controlVal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ControlPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ControlPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ctrl_type"),
    2: .same(proto: "runtime"),
    3: .standard(proto: "remote_client_info"),
    4: .same(proto: "status"),
    5: .standard(proto: "error_msg"),
    6: .standard(proto: "action_request"),
    7: .standard(proto: "module_annotations"),
    8: .standard(proto: "config_upload_payload"),
    9: .standard(proto: "log_message"),
    10: .standard(proto: "power_profile"),
    11: .standard(proto: "remote_function_request"),
    12: .standard(proto: "remote_function_return"),
    13: .standard(proto: "loose_direct_subscription"),
  ]

  fileprivate class _StorageClass {
    var _ctrlType: Claidservice_CtrlType = .ctrlUnspecified
    var _runtime: Claidservice_Runtime = .unspecified
    var _remoteClientInfo: Claidservice_RemoteClientInfo? = nil
    var _status: Claidservice_AccumulatedStatus? = nil
    var _errorMsg: Claidservice_ErrorMsg? = nil
    var _actionRequest: Claidservice_ActionRequest? = nil
    var _moduleAnnotations: Dictionary<String,Claidservice_ModuleAnnotation> = [:]
    var _configUploadPayload: Claidservice_ConfigUploadPayload? = nil
    var _logMessage: Claidservice_LogMessage? = nil
    var _powerProfile: Claidservice_PowerProfile? = nil
    var _remoteFunctionRequest: Claidservice_RemoteFunctionRequest? = nil
    var _remoteFunctionReturn: Claidservice_RemoteFunctionReturn? = nil
    var _looseDirectSubscription: Claidservice_LooseDirectChannelSubscription? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _ctrlType = source._ctrlType
      _runtime = source._runtime
      _remoteClientInfo = source._remoteClientInfo
      _status = source._status
      _errorMsg = source._errorMsg
      _actionRequest = source._actionRequest
      _moduleAnnotations = source._moduleAnnotations
      _configUploadPayload = source._configUploadPayload
      _logMessage = source._logMessage
      _powerProfile = source._powerProfile
      _remoteFunctionRequest = source._remoteFunctionRequest
      _remoteFunctionReturn = source._remoteFunctionReturn
      _looseDirectSubscription = source._looseDirectSubscription
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._ctrlType) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._runtime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._remoteClientInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._errorMsg) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._actionRequest) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Claidservice_ModuleAnnotation>.self, value: &_storage._moduleAnnotations) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._configUploadPayload) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._logMessage) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._powerProfile) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._remoteFunctionRequest) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._remoteFunctionReturn) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._looseDirectSubscription) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._ctrlType != .ctrlUnspecified {
        try visitor.visitSingularEnumField(value: _storage._ctrlType, fieldNumber: 1)
      }
      if _storage._runtime != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._runtime, fieldNumber: 2)
      }
      try { if let v = _storage._remoteClientInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._errorMsg {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._actionRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._moduleAnnotations.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Claidservice_ModuleAnnotation>.self, value: _storage._moduleAnnotations, fieldNumber: 7)
      }
      try { if let v = _storage._configUploadPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._logMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._powerProfile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._remoteFunctionRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._remoteFunctionReturn {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._looseDirectSubscription {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ControlPackage, rhs: Claidservice_ControlPackage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ctrlType != rhs_storage._ctrlType {return false}
        if _storage._runtime != rhs_storage._runtime {return false}
        if _storage._remoteClientInfo != rhs_storage._remoteClientInfo {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._errorMsg != rhs_storage._errorMsg {return false}
        if _storage._actionRequest != rhs_storage._actionRequest {return false}
        if _storage._moduleAnnotations != rhs_storage._moduleAnnotations {return false}
        if _storage._configUploadPayload != rhs_storage._configUploadPayload {return false}
        if _storage._logMessage != rhs_storage._logMessage {return false}
        if _storage._powerProfile != rhs_storage._powerProfile {return false}
        if _storage._remoteFunctionRequest != rhs_storage._remoteFunctionRequest {return false}
        if _storage._remoteFunctionReturn != rhs_storage._remoteFunctionReturn {return false}
        if _storage._looseDirectSubscription != rhs_storage._looseDirectSubscription {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_AccumulatedStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccumulatedStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_AccumulatedStatus, rhs: Claidservice_AccumulatedStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ErrorMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "cancel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.cancel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.cancel != false {
      try visitor.visitSingularBoolField(value: self.cancel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ErrorMsg, rhs: Claidservice_ErrorMsg) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.cancel != rhs.cancel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.actionParams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionParams.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.actionParams, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ActionRequest, rhs: Claidservice_ActionRequest) -> Bool {
    if lhs.actionParams != rhs.actionParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_IntVal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntVal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.val != 0 {
      try visitor.visitSingularInt64Field(value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_IntVal, rhs: Claidservice_IntVal) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_DoubleVal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleVal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.val.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_DoubleVal, rhs: Claidservice_DoubleVal) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_NumberArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumberArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitPackedDoubleField(value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_NumberArray, rhs: Claidservice_NumberArray) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_BoolVal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoolVal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.val != false {
      try visitor.visitSingularBoolField(value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_BoolVal, rhs: Claidservice_BoolVal) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_StringVal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringVal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitSingularStringField(value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_StringVal, rhs: Claidservice_StringVal) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_StringArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitRepeatedStringField(value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_StringArray, rhs: Claidservice_StringArray) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_NumberMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumberMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_NumberMap, rhs: Claidservice_NumberMap) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_StringMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "val"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.val) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.val.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.val, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_StringMap, rhs: Claidservice_StringMap) -> Bool {
    if lhs.val != rhs.val {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_Blob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Blob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codec"),
    2: .same(proto: "payload"),
    3: .standard(proto: "message_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.codec) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.messageType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codec != .unspecified {
      try visitor.visitSingularEnumField(value: self.codec, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.messageType.isEmpty {
      try visitor.visitSingularStringField(value: self.messageType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_Blob, rhs: Claidservice_Blob) -> Bool {
    if lhs.codec != rhs.codec {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.messageType != rhs.messageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_TracePoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TracePoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_stamp"),
    2: .standard(proto: "node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeStamp) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeStamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_TracePoint, rhs: Claidservice_TracePoint) -> Bool {
    if lhs._timeStamp != rhs._timeStamp {return false}
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ModuleListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "runtime"),
    2: .standard(proto: "supported_module_classes"),
    3: .standard(proto: "module_annotations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.runtime) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.supportedModuleClasses) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Claidservice_ModuleAnnotation>.self, value: &self.moduleAnnotations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.runtime != .unspecified {
      try visitor.visitSingularEnumField(value: self.runtime, fieldNumber: 1)
    }
    if !self.supportedModuleClasses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.supportedModuleClasses, fieldNumber: 2)
    }
    if !self.moduleAnnotations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Claidservice_ModuleAnnotation>.self, value: self.moduleAnnotations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ModuleListRequest, rhs: Claidservice_ModuleListRequest) -> Bool {
    if lhs.runtime != rhs.runtime {return false}
    if lhs.supportedModuleClasses != rhs.supportedModuleClasses {return false}
    if lhs.moduleAnnotations != rhs.moduleAnnotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ModuleListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "descriptors"),
    2: .standard(proto: "log_severity_level_for_host"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.descriptors) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.logSeverityLevelForHost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptors, fieldNumber: 1)
    }
    if self.logSeverityLevelForHost != .debugVerbose {
      try visitor.visitSingularEnumField(value: self.logSeverityLevelForHost, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ModuleListResponse, rhs: Claidservice_ModuleListResponse) -> Bool {
    if lhs.descriptors != rhs.descriptors {return false}
    if lhs.logSeverityLevelForHost != rhs.logSeverityLevelForHost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ModuleListResponse.ModuleDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Claidservice_ModuleListResponse.protoMessageName + ".ModuleDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_id"),
    2: .standard(proto: "module_class"),
    3: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleClass) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 1)
    }
    if !self.moduleClass.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleClass, fieldNumber: 2)
    }
    try { if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ModuleListResponse.ModuleDescriptor, rhs: Claidservice_ModuleListResponse.ModuleDescriptor) -> Bool {
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.moduleClass != rhs.moduleClass {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_InitRuntimeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitRuntimeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "runtime"),
    2: .same(proto: "modules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.runtime) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.runtime != .unspecified {
      try visitor.visitSingularEnumField(value: self.runtime, fieldNumber: 1)
    }
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_InitRuntimeRequest, rhs: Claidservice_InitRuntimeRequest) -> Bool {
    if lhs.runtime != rhs.runtime {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_InitRuntimeRequest.ModuleChannels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Claidservice_InitRuntimeRequest.protoMessageName + ".ModuleChannels"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_id"),
    2: .standard(proto: "channel_packets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.channelPackets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 1)
    }
    if !self.channelPackets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelPackets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_InitRuntimeRequest.ModuleChannels, rhs: Claidservice_InitRuntimeRequest.ModuleChannels) -> Bool {
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.channelPackets != rhs.channelPackets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_RemoteClientInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteClientInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .standard(proto: "user_token"),
    3: .standard(proto: "device_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.userToken.isEmpty {
      try visitor.visitSingularStringField(value: self.userToken, fieldNumber: 2)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_RemoteClientInfo, rhs: Claidservice_RemoteClientInfo) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.userToken != rhs.userToken {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_RemoveModuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveModuleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_RemoveModuleRequest, rhs: Claidservice_RemoveModuleRequest) -> Bool {
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_PropertyHint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PropertyHint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "property_type"),
    2: .standard(proto: "property_type_enum_values"),
    3: .standard(proto: "property_type_int_min"),
    4: .standard(proto: "property_type_int_max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.propertyType) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.propertyTypeEnumValues) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.propertyTypeIntMin) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.propertyTypeIntMax) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.propertyType != .default {
      try visitor.visitSingularEnumField(value: self.propertyType, fieldNumber: 1)
    }
    if !self.propertyTypeEnumValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.propertyTypeEnumValues, fieldNumber: 2)
    }
    if self.propertyTypeIntMin != 0 {
      try visitor.visitSingularInt64Field(value: self.propertyTypeIntMin, fieldNumber: 3)
    }
    if self.propertyTypeIntMax != 0 {
      try visitor.visitSingularInt64Field(value: self.propertyTypeIntMax, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_PropertyHint, rhs: Claidservice_PropertyHint) -> Bool {
    if lhs.propertyType != rhs.propertyType {return false}
    if lhs.propertyTypeEnumValues != rhs.propertyTypeEnumValues {return false}
    if lhs.propertyTypeIntMin != rhs.propertyTypeIntMin {return false}
    if lhs.propertyTypeIntMax != rhs.propertyTypeIntMax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ModuleAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_description"),
    2: .standard(proto: "module_category"),
    3: .same(proto: "properties"),
    4: .standard(proto: "property_descriptions"),
    5: .standard(proto: "property_hints"),
    6: .standard(proto: "channel_definition"),
    7: .standard(proto: "channel_description"),
    8: .standard(proto: "is_injectable"),
    9: .standard(proto: "file_dependencies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.moduleDescription) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleCategory) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.properties) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.propertyDescriptions) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.propertyHints) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.channelDefinition) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.channelDescription) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isInjectable) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.fileDependencies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moduleDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleDescription, fieldNumber: 1)
    }
    if !self.moduleCategory.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleCategory, fieldNumber: 2)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedStringField(value: self.properties, fieldNumber: 3)
    }
    if !self.propertyDescriptions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.propertyDescriptions, fieldNumber: 4)
    }
    if !self.propertyHints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.propertyHints, fieldNumber: 5)
    }
    if !self.channelDefinition.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelDefinition, fieldNumber: 6)
    }
    if !self.channelDescription.isEmpty {
      try visitor.visitRepeatedStringField(value: self.channelDescription, fieldNumber: 7)
    }
    if self.isInjectable != false {
      try visitor.visitSingularBoolField(value: self.isInjectable, fieldNumber: 8)
    }
    if !self.fileDependencies.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fileDependencies, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ModuleAnnotation, rhs: Claidservice_ModuleAnnotation) -> Bool {
    if lhs.moduleDescription != rhs.moduleDescription {return false}
    if lhs.moduleCategory != rhs.moduleCategory {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.propertyDescriptions != rhs.propertyDescriptions {return false}
    if lhs.propertyHints != rhs.propertyHints {return false}
    if lhs.channelDefinition != rhs.channelDefinition {return false}
    if lhs.channelDescription != rhs.channelDescription {return false}
    if lhs.isInjectable != rhs.isInjectable {return false}
    if lhs.fileDependencies != rhs.fileDependencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_LogMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_message"),
    2: .standard(proto: "severity_level"),
    3: .standard(proto: "unix_timestamp_in_ms"),
    4: .standard(proto: "entity_type"),
    5: .standard(proto: "entity_name"),
    6: .same(proto: "runtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logMessage) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.severityLevel) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.unixTimestampInMs) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.entityType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.entityName) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.runtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.logMessage, fieldNumber: 1)
    }
    if self.severityLevel != .debugVerbose {
      try visitor.visitSingularEnumField(value: self.severityLevel, fieldNumber: 2)
    }
    if self.unixTimestampInMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.unixTimestampInMs, fieldNumber: 3)
    }
    if self.entityType != .middleware {
      try visitor.visitSingularEnumField(value: self.entityType, fieldNumber: 4)
    }
    if !self.entityName.isEmpty {
      try visitor.visitSingularStringField(value: self.entityName, fieldNumber: 5)
    }
    if self.runtime != .unspecified {
      try visitor.visitSingularEnumField(value: self.runtime, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_LogMessage, rhs: Claidservice_LogMessage) -> Bool {
    if lhs.logMessage != rhs.logMessage {return false}
    if lhs.severityLevel != rhs.severityLevel {return false}
    if lhs.unixTimestampInMs != rhs.unixTimestampInMs {return false}
    if lhs.entityType != rhs.entityType {return false}
    if lhs.entityName != rhs.entityName {return false}
    if lhs.runtime != rhs.runtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_CLAIDConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CLAIDConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hosts"),
    2: .standard(proto: "log_sink_host"),
    3: .standard(proto: "log_sink_severity_level"),
    4: .standard(proto: "log_sink_transfer_mode"),
    5: .standard(proto: "log_sink_log_storage_path"),
    7: .standard(proto: "milliseconds_deadline_to_load_modules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hosts) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.logSinkHost) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.logSinkSeverityLevel) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.logSinkTransferMode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.logSinkLogStoragePath) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.millisecondsDeadlineToLoadModules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hosts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hosts, fieldNumber: 1)
    }
    if !self.logSinkHost.isEmpty {
      try visitor.visitSingularStringField(value: self.logSinkHost, fieldNumber: 2)
    }
    if self.logSinkSeverityLevel != .debugVerbose {
      try visitor.visitSingularEnumField(value: self.logSinkSeverityLevel, fieldNumber: 3)
    }
    if self.logSinkTransferMode != .storeAndUpload {
      try visitor.visitSingularEnumField(value: self.logSinkTransferMode, fieldNumber: 4)
    }
    if !self.logSinkLogStoragePath.isEmpty {
      try visitor.visitSingularStringField(value: self.logSinkLogStoragePath, fieldNumber: 5)
    }
    if self.millisecondsDeadlineToLoadModules != 0 {
      try visitor.visitSingularInt32Field(value: self.millisecondsDeadlineToLoadModules, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_CLAIDConfig, rhs: Claidservice_CLAIDConfig) -> Bool {
    if lhs.hosts != rhs.hosts {return false}
    if lhs.logSinkHost != rhs.logSinkHost {return false}
    if lhs.logSinkSeverityLevel != rhs.logSinkSeverityLevel {return false}
    if lhs.logSinkTransferMode != rhs.logSinkTransferMode {return false}
    if lhs.logSinkLogStoragePath != rhs.logSinkLogStoragePath {return false}
    if lhs.millisecondsDeadlineToLoadModules != rhs.millisecondsDeadlineToLoadModules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_HostConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HostConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hostname"),
    2: .same(proto: "type"),
    3: .standard(proto: "server_config"),
    4: .standard(proto: "connect_to"),
    5: .same(proto: "modules"),
    6: .standard(proto: "log_folder"),
    7: .standard(proto: "min_log_severity_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serverConfig) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._connectTo) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.modules) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.logFolder) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.minLogSeverityLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._serverConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._connectTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 5)
    }
    if !self.logFolder.isEmpty {
      try visitor.visitSingularStringField(value: self.logFolder, fieldNumber: 6)
    }
    if self.minLogSeverityLevel != .debugVerbose {
      try visitor.visitSingularEnumField(value: self.minLogSeverityLevel, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_HostConfig, rhs: Claidservice_HostConfig) -> Bool {
    if lhs.hostname != rhs.hostname {return false}
    if lhs.type != rhs.type {return false}
    if lhs._serverConfig != rhs._serverConfig {return false}
    if lhs._connectTo != rhs._connectTo {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.logFolder != rhs.logFolder {return false}
    if lhs.minLogSeverityLevel != rhs.minLogSeverityLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ClientConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "tls"),
    3: .standard(proto: "mutual_tls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try {
        var v: Claidservice_ClientTLSConfigServerBasedAuthentication?
        var hadOneofValue = false
        if let current = self.securitySettings {
          hadOneofValue = true
          if case .tls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.securitySettings = .tls(v)
        }
      }()
      case 3: try {
        var v: Claidservice_ClientTLSConfigMutualAuthentication?
        var hadOneofValue = false
        if let current = self.securitySettings {
          hadOneofValue = true
          if case .mutualTls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.securitySettings = .mutualTls(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    switch self.securitySettings {
    case .tls?: try {
      guard case .tls(let v)? = self.securitySettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .mutualTls?: try {
      guard case .mutualTls(let v)? = self.securitySettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ClientConfig, rhs: Claidservice_ClientConfig) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.securitySettings != rhs.securitySettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ServerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "host_server_address"),
    2: .same(proto: "tls"),
    3: .standard(proto: "mutual_tls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostServerAddress) }()
      case 2: try {
        var v: Claidservice_ServerTLSConfigServerBasedAuthentication?
        var hadOneofValue = false
        if let current = self.securitySettings {
          hadOneofValue = true
          if case .tls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.securitySettings = .tls(v)
        }
      }()
      case 3: try {
        var v: Claidservice_ServerTLSConfigMutualAuthentication?
        var hadOneofValue = false
        if let current = self.securitySettings {
          hadOneofValue = true
          if case .mutualTls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.securitySettings = .mutualTls(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hostServerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.hostServerAddress, fieldNumber: 1)
    }
    switch self.securitySettings {
    case .tls?: try {
      guard case .tls(let v)? = self.securitySettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .mutualTls?: try {
      guard case .mutualTls(let v)? = self.securitySettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ServerConfig, rhs: Claidservice_ServerConfig) -> Bool {
    if lhs.hostServerAddress != rhs.hostServerAddress {return false}
    if lhs.securitySettings != rhs.securitySettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ClientTLSConfigServerBasedAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientTLSConfigServerBasedAuthentication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_public_certificate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverPublicCertificate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverPublicCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.serverPublicCertificate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ClientTLSConfigServerBasedAuthentication, rhs: Claidservice_ClientTLSConfigServerBasedAuthentication) -> Bool {
    if lhs.serverPublicCertificate != rhs.serverPublicCertificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ClientTLSConfigMutualAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientTLSConfigMutualAuthentication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_public_certificate"),
    2: .standard(proto: "client_private_key"),
    3: .standard(proto: "server_public_certificate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientPublicCertificate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clientPrivateKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverPublicCertificate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientPublicCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.clientPublicCertificate, fieldNumber: 1)
    }
    if !self.clientPrivateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.clientPrivateKey, fieldNumber: 2)
    }
    if !self.serverPublicCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.serverPublicCertificate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ClientTLSConfigMutualAuthentication, rhs: Claidservice_ClientTLSConfigMutualAuthentication) -> Bool {
    if lhs.clientPublicCertificate != rhs.clientPublicCertificate {return false}
    if lhs.clientPrivateKey != rhs.clientPrivateKey {return false}
    if lhs.serverPublicCertificate != rhs.serverPublicCertificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ServerTLSConfigServerBasedAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerTLSConfigServerBasedAuthentication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_public_certificate"),
    2: .standard(proto: "server_private_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverPublicCertificate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverPrivateKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverPublicCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.serverPublicCertificate, fieldNumber: 1)
    }
    if !self.serverPrivateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serverPrivateKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ServerTLSConfigServerBasedAuthentication, rhs: Claidservice_ServerTLSConfigServerBasedAuthentication) -> Bool {
    if lhs.serverPublicCertificate != rhs.serverPublicCertificate {return false}
    if lhs.serverPrivateKey != rhs.serverPrivateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ServerTLSConfigMutualAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerTLSConfigMutualAuthentication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_public_certificate"),
    2: .standard(proto: "server_private_key"),
    3: .standard(proto: "client_public_certificate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverPublicCertificate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverPrivateKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientPublicCertificate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverPublicCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.serverPublicCertificate, fieldNumber: 1)
    }
    if !self.serverPrivateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serverPrivateKey, fieldNumber: 2)
    }
    if !self.clientPublicCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.clientPublicCertificate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ServerTLSConfigMutualAuthentication, rhs: Claidservice_ServerTLSConfigMutualAuthentication) -> Bool {
    if lhs.serverPublicCertificate != rhs.serverPublicCertificate {return false}
    if lhs.serverPrivateKey != rhs.serverPrivateKey {return false}
    if lhs.clientPublicCertificate != rhs.clientPublicCertificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ModuleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "input_channels"),
    4: .standard(proto: "output_channels"),
    5: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.inputChannels) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.outputChannels) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    if !self.inputChannels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.inputChannels, fieldNumber: 3)
    }
    if !self.outputChannels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.outputChannels, fieldNumber: 4)
    }
    try { if let v = self._properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ModuleConfig, rhs: Claidservice_ModuleConfig) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.inputChannels != rhs.inputChannels {return false}
    if lhs.outputChannels != rhs.outputChannels {return false}
    if lhs._properties != rhs._properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_DataFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "relative_path"),
    2: .standard(proto: "file_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.relativePath) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.fileData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.relativePath.isEmpty {
      try visitor.visitSingularStringField(value: self.relativePath, fieldNumber: 1)
    }
    if !self.fileData.isEmpty {
      try visitor.visitSingularBytesField(value: self.fileData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_DataFile, rhs: Claidservice_DataFile) -> Bool {
    if lhs.relativePath != rhs.relativePath {return false}
    if lhs.fileData != rhs.fileData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ModuleInjectionDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleInjectionDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_name"),
    2: .standard(proto: "module_file"),
    3: .same(proto: "runtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.moduleName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.moduleFile) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.runtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moduleName.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleName, fieldNumber: 1)
    }
    if !self.moduleFile.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleFile, fieldNumber: 2)
    }
    if self.runtime != .unspecified {
      try visitor.visitSingularEnumField(value: self.runtime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ModuleInjectionDescription, rhs: Claidservice_ModuleInjectionDescription) -> Bool {
    if lhs.moduleName != rhs.moduleName {return false}
    if lhs.moduleFile != rhs.moduleFile {return false}
    if lhs.runtime != rhs.runtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ConfigUploadPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigUploadPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .standard(proto: "payload_files"),
    3: .standard(proto: "modules_to_inject"),
    4: .standard(proto: "payload_data_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.payloadFiles) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.modulesToInject) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payloadDataPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.payloadFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payloadFiles, fieldNumber: 2)
    }
    if !self.modulesToInject.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modulesToInject, fieldNumber: 3)
    }
    if !self.payloadDataPath.isEmpty {
      try visitor.visitSingularStringField(value: self.payloadDataPath, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ConfigUploadPayload, rhs: Claidservice_ConfigUploadPayload) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.payloadFiles != rhs.payloadFiles {return false}
    if lhs.modulesToInject != rhs.modulesToInject {return false}
    if lhs.payloadDataPath != rhs.payloadDataPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_PowerProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowerProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "power_profile_type"),
    2: .same(proto: "frequency"),
    3: .same(proto: "period"),
    4: .standard(proto: "additional_information"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.powerProfileType) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.frequency) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.period) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.additionalInformation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.powerProfileType != .unrestricted {
      try visitor.visitSingularEnumField(value: self.powerProfileType, fieldNumber: 1)
    }
    if self.frequency.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.frequency, fieldNumber: 2)
    }
    if self.period.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.period, fieldNumber: 3)
    }
    if !self.additionalInformation.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.additionalInformation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_PowerProfile, rhs: Claidservice_PowerProfile) -> Bool {
    if lhs.powerProfileType != rhs.powerProfileType {return false}
    if lhs.frequency != rhs.frequency {return false}
    if lhs.period != rhs.period {return false}
    if lhs.additionalInformation != rhs.additionalInformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_PowerSavingStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowerSavingStrategy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "battery_threshold"),
    2: .standard(proto: "active_modules"),
    3: .standard(proto: "paused_modules"),
    4: .standard(proto: "power_profiles"),
    5: .standard(proto: "wake_lock"),
    6: .standard(proto: "disable_network_connections"),
    7: .standard(proto: "disable_wifi_and_bluetooth"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.batteryThreshold) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.activeModules) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.pausedModules) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Claidservice_PowerProfile>.self, value: &self.powerProfiles) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.wakeLock) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disableNetworkConnections) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disableWifiAndBluetooth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batteryThreshold.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.batteryThreshold, fieldNumber: 1)
    }
    if !self.activeModules.isEmpty {
      try visitor.visitRepeatedStringField(value: self.activeModules, fieldNumber: 2)
    }
    if !self.pausedModules.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pausedModules, fieldNumber: 3)
    }
    if !self.powerProfiles.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Claidservice_PowerProfile>.self, value: self.powerProfiles, fieldNumber: 4)
    }
    if self.wakeLock != false {
      try visitor.visitSingularBoolField(value: self.wakeLock, fieldNumber: 5)
    }
    if self.disableNetworkConnections != false {
      try visitor.visitSingularBoolField(value: self.disableNetworkConnections, fieldNumber: 6)
    }
    if self.disableWifiAndBluetooth != false {
      try visitor.visitSingularBoolField(value: self.disableWifiAndBluetooth, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_PowerSavingStrategy, rhs: Claidservice_PowerSavingStrategy) -> Bool {
    if lhs.batteryThreshold != rhs.batteryThreshold {return false}
    if lhs.activeModules != rhs.activeModules {return false}
    if lhs.pausedModules != rhs.pausedModules {return false}
    if lhs.powerProfiles != rhs.powerProfiles {return false}
    if lhs.wakeLock != rhs.wakeLock {return false}
    if lhs.disableNetworkConnections != rhs.disableNetworkConnections {return false}
    if lhs.disableWifiAndBluetooth != rhs.disableWifiAndBluetooth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_PowerSavingStrategyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowerSavingStrategyList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strategies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.strategies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.strategies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.strategies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_PowerSavingStrategyList, rhs: Claidservice_PowerSavingStrategyList) -> Bool {
    if lhs.strategies != rhs.strategies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_CLAIDANY: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CLAIDANY"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_CLAIDANY, rhs: Claidservice_CLAIDANY) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_RemoteFunctionIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteFunctionIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_name"),
    2: .same(proto: "runtime"),
    3: .standard(proto: "module_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      case 2: try {
        var v: Claidservice_Runtime?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.functionType != nil {try decoder.handleConflictingOneOf()}
          self.functionType = .runtime(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.functionType != nil {try decoder.handleConflictingOneOf()}
          self.functionType = .moduleID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 1)
    }
    switch self.functionType {
    case .runtime?: try {
      guard case .runtime(let v)? = self.functionType else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .moduleID?: try {
      guard case .moduleID(let v)? = self.functionType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_RemoteFunctionIdentifier, rhs: Claidservice_RemoteFunctionIdentifier) -> Bool {
    if lhs.functionName != rhs.functionName {return false}
    if lhs.functionType != rhs.functionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_RemoteFunctionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteFunctionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "remote_function_identifier"),
    2: .standard(proto: "remote_future_identifier"),
    3: .standard(proto: "parameter_payloads"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._remoteFunctionIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.remoteFutureIdentifier) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parameterPayloads) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._remoteFunctionIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.remoteFutureIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteFutureIdentifier, fieldNumber: 2)
    }
    if !self.parameterPayloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameterPayloads, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_RemoteFunctionRequest, rhs: Claidservice_RemoteFunctionRequest) -> Bool {
    if lhs._remoteFunctionIdentifier != rhs._remoteFunctionIdentifier {return false}
    if lhs.remoteFutureIdentifier != rhs.remoteFutureIdentifier {return false}
    if lhs.parameterPayloads != rhs.parameterPayloads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_RemoteFunctionReturn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteFunctionReturn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "execution_status"),
    2: .standard(proto: "remote_function_identifier"),
    3: .standard(proto: "remote_future_identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.executionStatus) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._remoteFunctionIdentifier) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.remoteFutureIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.executionStatus != .undefined {
      try visitor.visitSingularEnumField(value: self.executionStatus, fieldNumber: 1)
    }
    try { if let v = self._remoteFunctionIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.remoteFutureIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteFutureIdentifier, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_RemoteFunctionReturn, rhs: Claidservice_RemoteFunctionReturn) -> Bool {
    if lhs.executionStatus != rhs.executionStatus {return false}
    if lhs._remoteFunctionIdentifier != rhs._remoteFunctionIdentifier {return false}
    if lhs.remoteFutureIdentifier != rhs.remoteFutureIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_LooseDirectChannelSubscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LooseDirectChannelSubscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscriber_runtime"),
    2: .standard(proto: "subscriber_entity"),
    3: .standard(proto: "subscribed_module"),
    4: .standard(proto: "subscribed_channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.subscriberRuntime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subscriberEntity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subscribedModule) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subscribedChannel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscriberRuntime != .unspecified {
      try visitor.visitSingularEnumField(value: self.subscriberRuntime, fieldNumber: 1)
    }
    if !self.subscriberEntity.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriberEntity, fieldNumber: 2)
    }
    if !self.subscribedModule.isEmpty {
      try visitor.visitSingularStringField(value: self.subscribedModule, fieldNumber: 3)
    }
    if !self.subscribedChannel.isEmpty {
      try visitor.visitSingularStringField(value: self.subscribedChannel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_LooseDirectChannelSubscription, rhs: Claidservice_LooseDirectChannelSubscription) -> Bool {
    if lhs.subscriberRuntime != rhs.subscriberRuntime {return false}
    if lhs.subscriberEntity != rhs.subscriberEntity {return false}
    if lhs.subscribedModule != rhs.subscribedModule {return false}
    if lhs.subscribedChannel != rhs.subscribedChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_DataSyncFileDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataSyncFileDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_size"),
    2: .same(proto: "hash"),
    3: .standard(proto: "relative_file_path"),
    4: .standard(proto: "file_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fileSize) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.hash) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relativeFilePath) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.fileData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fileSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.fileSize, fieldNumber: 1)
    }
    if self.hash != 0 {
      try visitor.visitSingularUInt64Field(value: self.hash, fieldNumber: 2)
    }
    if !self.relativeFilePath.isEmpty {
      try visitor.visitSingularStringField(value: self.relativeFilePath, fieldNumber: 3)
    }
    if !self.fileData.isEmpty {
      try visitor.visitSingularBytesField(value: self.fileData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_DataSyncFileDescriptor, rhs: Claidservice_DataSyncFileDescriptor) -> Bool {
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.relativeFilePath != rhs.relativeFilePath {return false}
    if lhs.fileData != rhs.fileData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_DataSyncFileDescriptorList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataSyncFileDescriptorList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "descriptors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.descriptors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_DataSyncFileDescriptorList, rhs: Claidservice_DataSyncFileDescriptorList) -> Bool {
    if lhs.descriptors != rhs.descriptors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_DataSyncPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataSyncPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_type"),
    2: .standard(proto: "file_descriptors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.packageType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fileDescriptors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.packageType != .allAvailableFilesList {
      try visitor.visitSingularEnumField(value: self.packageType, fieldNumber: 1)
    }
    try { if let v = self._fileDescriptors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_DataSyncPackage, rhs: Claidservice_DataSyncPackage) -> Bool {
    if lhs.packageType != rhs.packageType {return false}
    if lhs._fileDescriptors != rhs._fileDescriptors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_RuntimeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "runtime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.runtime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.runtime != .unspecified {
      try visitor.visitSingularEnumField(value: self.runtime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_RuntimeType, rhs: Claidservice_RuntimeType) -> Bool {
    if lhs.runtime != rhs.runtime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Schedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "periodic"),
    2: .same(proto: "timed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.periodic) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.timed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.periodic.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.periodic, fieldNumber: 1)
    }
    if !self.timed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_Schedule, rhs: Claidservice_Schedule) -> Bool {
    if lhs.periodic != rhs.periodic {return false}
    if lhs.timed != rhs.timed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ScheduleTimeWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScheduleTimeWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time_of_day"),
    2: .standard(proto: "stop_time_of_day"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTimeOfDay) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stopTimeOfDay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTimeOfDay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stopTimeOfDay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ScheduleTimeWindow, rhs: Claidservice_ScheduleTimeWindow) -> Bool {
    if lhs._startTimeOfDay != rhs._startTimeOfDay {return false}
    if lhs._stopTimeOfDay != rhs._stopTimeOfDay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ScheduleTimeOfDay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScheduleTimeOfDay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hour"),
    2: .same(proto: "minute"),
    3: .same(proto: "second"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.hour) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minute) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.second) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hour != 0 {
      try visitor.visitSingularInt32Field(value: self.hour, fieldNumber: 1)
    }
    if self.minute != 0 {
      try visitor.visitSingularInt32Field(value: self.minute, fieldNumber: 2)
    }
    if self.second != 0 {
      try visitor.visitSingularInt32Field(value: self.second, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ScheduleTimeOfDay, rhs: Claidservice_ScheduleTimeOfDay) -> Bool {
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.second != rhs.second {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_SchedulePeriodic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SchedulePeriodic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "first_execution_time_of_day"),
    2: .standard(proto: "only_active_between_time_frame"),
    3: .standard(proto: "frequency_Hz"),
    4: .standard(proto: "frequency_kHz"),
    5: .standard(proto: "frequency_MHz"),
    6: .standard(proto: "period_milliseconds"),
    7: .standard(proto: "period_seconds"),
    8: .standard(proto: "period_minutes"),
    9: .standard(proto: "period_hours"),
    10: .standard(proto: "period_days"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._firstExecutionTimeOfDay) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._onlyActiveBetweenTimeFrame) }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.interval != nil {try decoder.handleConflictingOneOf()}
          self.interval = .frequencyHz(v)
        }
      }()
      case 4: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.interval != nil {try decoder.handleConflictingOneOf()}
          self.interval = .frequencyKHz(v)
        }
      }()
      case 5: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.interval != nil {try decoder.handleConflictingOneOf()}
          self.interval = .frequencyMhz(v)
        }
      }()
      case 6: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.interval != nil {try decoder.handleConflictingOneOf()}
          self.interval = .periodMilliseconds(v)
        }
      }()
      case 7: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.interval != nil {try decoder.handleConflictingOneOf()}
          self.interval = .periodSeconds(v)
        }
      }()
      case 8: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.interval != nil {try decoder.handleConflictingOneOf()}
          self.interval = .periodMinutes(v)
        }
      }()
      case 9: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.interval != nil {try decoder.handleConflictingOneOf()}
          self.interval = .periodHours(v)
        }
      }()
      case 10: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.interval != nil {try decoder.handleConflictingOneOf()}
          self.interval = .periodDays(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._firstExecutionTimeOfDay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._onlyActiveBetweenTimeFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.interval {
    case .frequencyHz?: try {
      guard case .frequencyHz(let v)? = self.interval else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .frequencyKHz?: try {
      guard case .frequencyKHz(let v)? = self.interval else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case .frequencyMhz?: try {
      guard case .frequencyMhz(let v)? = self.interval else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }()
    case .periodMilliseconds?: try {
      guard case .periodMilliseconds(let v)? = self.interval else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 6)
    }()
    case .periodSeconds?: try {
      guard case .periodSeconds(let v)? = self.interval else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 7)
    }()
    case .periodMinutes?: try {
      guard case .periodMinutes(let v)? = self.interval else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 8)
    }()
    case .periodHours?: try {
      guard case .periodHours(let v)? = self.interval else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 9)
    }()
    case .periodDays?: try {
      guard case .periodDays(let v)? = self.interval else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_SchedulePeriodic, rhs: Claidservice_SchedulePeriodic) -> Bool {
    if lhs._firstExecutionTimeOfDay != rhs._firstExecutionTimeOfDay {return false}
    if lhs._onlyActiveBetweenTimeFrame != rhs._onlyActiveBetweenTimeFrame {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Claidservice_ScheduleExactTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScheduleExactTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_of_day"),
    2: .standard(proto: "repeat_every_n_days"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeOfDay) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.repeatEveryNDays) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeOfDay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.repeatEveryNDays.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.repeatEveryNDays, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Claidservice_ScheduleExactTime, rhs: Claidservice_ScheduleExactTime) -> Bool {
    if lhs._timeOfDay != rhs._timeOfDay {return false}
    if lhs.repeatEveryNDays != rhs.repeatEveryNDays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
